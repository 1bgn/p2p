//== FILE: test/widget_test.dart ==//
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:beam_drop/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

//== END FILE: test/widget_test.dart ==//

//== FILE: pubspec.yaml ==//
name: beam_drop
description: "A new Flutter project."

publish_to: 'none' # Remove this line if you wish to publish to pub.dev

version: 1.0.0+1

environment:
  sdk: ^3.8.0

dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.8
  permission_handler: ^12.0.0+1
  file_picker: ^10.1.9
  path_provider: ^2.1.5
  json_annotation: ^4.9.0
  freezed_annotation: ^3.0.0
  get_it: ^8.0.3
  injectable: ^2.5.0
  signals: ^6.0.2
  signals_flutter: ^6.0.2
  auto_route: ^10.0.1
  flutter_svg: ^2.1.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  freezed: ^3.0.6

  flutter_lints: ^5.0.0
  build_runner: ^2.4.15
  json_serializable: any
  auto_route_generator: ^10.0.1
  injectable_generator: ^2.7.0


flutter:
  uses-material-design: true


  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg


//== END FILE: pubspec.yaml ==//

//== FILE: lib/di/injectable.config.dart ==//
// dart format width=80
// GENERATED CODE - DO NOT MODIFY BY HAND

// **************************************************************************
// InjectableConfigGenerator
// **************************************************************************

// ignore_for_file: type=lint
// coverage:ignore-file

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:beam_drop/di/injectable_module.dart' as _i965;
import 'package:beam_drop/features/discovery_screen/application/tcp_client.dart'
    as _i919;
import 'package:beam_drop/features/discovery_screen/application/tcp_server.dart'
    as _i206;
import 'package:beam_drop/features/discovery_screen/presentation/controller/connection_controller.dart'
    as _i970;
import 'package:beam_drop/features/discovery_screen/presentation/controller/discovery_controller.dart'
    as _i305;
import 'package:beam_drop/router/app_router.dart' as _i413;
import 'package:get_it/get_it.dart' as _i174;
import 'package:injectable/injectable.dart' as _i526;

extension GetItInjectableX on _i174.GetIt {
  // initializes the registration of main-scope dependencies inside of GetIt
  _i174.GetIt init({
    String? environment,
    _i526.EnvironmentFilter? environmentFilter,
  }) {
    final gh = _i526.GetItHelper(this, environment, environmentFilter);
    final injectableModule = _$InjectableModule();
    gh.lazySingleton<_i413.AppRouter>(() => injectableModule.appRouter);
    gh.lazySingleton<_i919.TcpClient>(() => _i919.TcpClient());
    gh.lazySingleton<_i206.TcpServer>(() => _i206.TcpServer());
    gh.lazySingleton<_i305.DiscoveryController>(
      () => _i305.DiscoveryController(),
    );
    gh.lazySingleton<_i970.ConnectionController>(
      () => _i970.ConnectionController(
        client: gh<_i919.TcpClient>(),
        server: gh<_i206.TcpServer>(),
      ),
    );
    return this;
  }
}

class _$InjectableModule extends _i965.InjectableModule {}

//== END FILE: lib/di/injectable.config.dart ==//

//== FILE: lib/di/injectable.dart ==//
import 'package:get_it/get_it.dart';
import 'package:injectable/injectable.dart';
import 'injectable.config.dart'; // будет сгенерирован автоматически

final getIt = GetIt.instance;

@injectableInit
void configureDependencies() => getIt.init();
//== END FILE: lib/di/injectable.dart ==//

//== FILE: lib/di/injectable_module.dart ==//
import 'package:beam_drop/router/app_router.dart';
import 'package:injectable/injectable.dart';

@module
abstract class InjectableModule{
  @lazySingleton
  AppRouter get appRouter =>AppRouter();
}
//== END FILE: lib/di/injectable_module.dart ==//

//== FILE: lib/features/transfer_screen/presentation/ui/transfer_sceren.dart ==//
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:auto_route/auto_route.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';

/// Simple text chat + file transfer over an already‑established [Socket].
/// Protocol:
/// * Text: raw UTF‑8 string (one message per socket.write).

/// * File: header line **FILE:<fileName>:<bytes>
///   byte payload. Receiver creates a file in app‑documents.
///
@RoutePage()
class TransferScreen extends StatefulWidget {
  final Socket socket;
  final String remoteRoomCode;

  const TransferScreen({
    super.key,
    required this.socket,
    required this.remoteRoomCode,
  });

  @override
  State<TransferScreen> createState() => _TransferScreenState();
}

class _TransferScreenState extends State<TransferScreen> {
  final _messages = <String>[];
  final _textController = TextEditingController();

  // File‑receive state
  bool _receivingFile = false;
  late int _bytesRemaining;
  late IOSink _fileSink;
  String _currentFileName = '';

  @override
  void initState() {
    super.initState();
    widget.socket.listen(_onData, onDone: () => Navigator.of(context).pop());
  }

  void _onData(Uint8List data) async {
    var buffer = data;
    while (buffer.isNotEmpty) {
      if (_receivingFile) {
        final toWrite = buffer.length > _bytesRemaining
            ? buffer.sublist(0, _bytesRemaining)
            : buffer;
        _fileSink.add(toWrite);
        _bytesRemaining -= toWrite.length;
        buffer = buffer.sublist(toWrite.length);
        if (_bytesRemaining == 0) {
          await _fileSink.flush();
          await _fileSink.close();
          setState(() => _messages.add('📥 Received file $_currentFileName'));
          _receivingFile = false;
        }
      } else {
        final newlineIdx = buffer.indexOf(10); //

        if (newlineIdx == -1) {
          // No newline – assume entire buffer is text
          final text = utf8.decode(buffer);
          setState(() => _messages.add('Remote: $text'));
          break;
        }
        final lineBytes = buffer.sublist(0, newlineIdx);
        final line = utf8.decode(lineBytes);
        buffer = buffer.sublist(newlineIdx + 1);

        if (line.startsWith('FILE:')) {
          final parts = line.split(':');
          if (parts.length >= 3) {
            _currentFileName = parts[1];
            _bytesRemaining = int.parse(parts[2]);
            final dir = await getApplicationDocumentsDirectory();
            final file = File('${dir.path}/$_currentFileName');
            _fileSink = file.openWrite();
            _receivingFile = true;
          }
        } else {
          setState(() => _messages.add('Remote: $line'));
        }
      }
    }
  }

  Future<void> _sendText() async {
    final text = _textController.text.trim();
    if (text.isEmpty) return;
    widget.socket.write(text.toString());
        await widget.socket.flush();
    setState(() => _messages.add('Me: $text'));
    _textController.clear();
  }

  Future<void> _sendFile() async {
    final result = await FilePicker.platform.pickFiles();
    if (result == null || result.files.single.path == null) return;
    final file = File(result.files.single.path!);
    final bytes = await file.readAsBytes();

    // Header line ends with

    final header = 'FILE:${file.uri.pathSegments.last}:${bytes.length}';
    widget.socket.add(utf8.encode(header));
    widget.socket.add(bytes);
    await widget.socket.flush();

    setState(() => _messages.add('Me: Sent file ${file.uri.pathSegments.last}'));
  }

  @override
  void dispose() {
    _textController.dispose();
    widget.socket.destroy();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Chat with ${widget.remoteRoomCode}')),
      body: Column(
        children: [
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.all(8),
              itemCount: _messages.length,
              itemBuilder: (_, i) => Text(_messages[i]),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: _textController,
                    onSubmitted: (_) => _sendText(),
                    decoration: const InputDecoration(labelText: 'Say something'),
                  ),
                ),
                IconButton(onPressed: _sendFile, icon: const Icon(Icons.attach_file)),
                IconButton(onPressed: _sendText, icon: const Icon(Icons.send)),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
//== END FILE: lib/features/transfer_screen/presentation/ui/transfer_sceren.dart ==//

//== FILE: lib/features/discovery_screen/application/tcp_server.dart ==//
import 'dart:async';
import 'dart:io';

import 'package:injectable/injectable.dart';
@LazySingleton()
class TcpServer {
  late final ServerSocket _server;
  final _clientController = StreamController<Socket>.broadcast();
  Stream<Socket> get clientStream => _clientController.stream;

  Future<int> start({int preferredPort = 8080}) async {
    _server = await ServerSocket.bind(InternetAddress.anyIPv4, preferredPort);
    _server.listen((client) => _clientController.add(client));
    return _server.port; // Might differ if preferredPort was 0
  }

  Future<void> stop() async {
    await _server.close();
  }
}
//== END FILE: lib/features/discovery_screen/application/tcp_server.dart ==//

//== FILE: lib/features/discovery_screen/application/discovery_service.dart ==//
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import '../domain/models/device_info.dart';

const int discoveryPort = 12345; // UDP discovery port
const Duration discoveryInterval = Duration(seconds: 2);
const String discoveryMessagePrefix = 'DISCOVER:';
final InternetAddress _broadcastAddress = InternetAddress('255.255.255.255');
class DiscoveryService {
  DiscoveryService._internal();
  static final DiscoveryService instance = DiscoveryService._internal();

  final _controller = StreamController<List<DeviceInfo>>.broadcast();
  RawDatagramSocket? _listenSocket;
  RawDatagramSocket? _broadcastSocket;
  Timer? _broadcastTimer;
  final Map<String, DeviceInfo> _devices = {};

  Stream<List<DeviceInfo>> get devicesStream => _controller.stream;

  Future<void> start(String myRoomCode, int tcpPort) async {
    await _startListening();
    await _startBroadcasting(myRoomCode, tcpPort);
  }

  Future<void> stop() async {
     _broadcastTimer?.cancel();
    _broadcastSocket?.close();
    _listenSocket?.close();
    _devices.clear();
  }

  Future<void> _startListening() async {
    _listenSocket = await RawDatagramSocket.bind(InternetAddress.anyIPv4, discoveryPort, reuseAddress: true, reusePort: true);
    _listenSocket!.listen((event) {
      if (event == RawSocketEvent.read) {
        final dg = _listenSocket!.receive();
        if (dg == null) return;
        final msg = utf8.decode(dg.data);
        if (!msg.startsWith(discoveryMessagePrefix)) return;
        // DISCOVER:<roomCode>:<tcpPort>
        final parts = msg.split(':');
        if (parts.length < 3) return;
        final room = parts[1];
        final tcpPort = int.tryParse(parts[2]) ?? 0;
        final key = '${dg.address.address}:$room';
        _devices[key] = DeviceInfo(
          roomCode: room,
          ip: dg.address.address,
          tcpPort: tcpPort,
          lastSeen: DateTime.now(),
        );
        _controller.add(_devices.values.toList());
      }
    });
  }

  Future<void> _startBroadcasting(String myRoomCode, int tcpPort) async {
    _broadcastSocket = await RawDatagramSocket.bind(InternetAddress.anyIPv4, 0);
    _broadcastSocket!.broadcastEnabled = true;
    _broadcastTimer = Timer.periodic(discoveryInterval, (_) {
      final msg = '$discoveryMessagePrefix$myRoomCode:$tcpPort';
      final dg = Datagram(utf8.encode(msg), _broadcastAddress, discoveryPort);
      _broadcastSocket!.send(dg.data, dg.address, dg.port);
    });
  }
}
//== END FILE: lib/features/discovery_screen/application/discovery_service.dart ==//

//== FILE: lib/features/discovery_screen/application/tcp_client.dart ==//
import 'dart:convert';
import 'dart:io';

import 'package:injectable/injectable.dart';
@LazySingleton()
class TcpClient {
  Future<Socket> connect(String ip, int port) async {
    final socket = await Socket.connect(ip, port);
    return socket;
  }

  /// Returns a stream of UTF‑8 lines arriving from [socket].
  ///
  /// We cast the underlying `Uint8List` chunks to `List<int>` so that
  /// `utf8.decoder` fits the generic constraints of `Stream.transform`.
  Stream<String> readLines(Socket socket) {
    return socket
        .cast<List<int>>()              // make the type compatible
        .transform(utf8.decoder)        // bytes → string
        .transform(const LineSplitter());
  }
}
//== END FILE: lib/features/discovery_screen/application/tcp_client.dart ==//

//== FILE: lib/features/discovery_screen/domain/models/device_info.dart ==//
import 'package:freezed_annotation/freezed_annotation.dart';

part 'device_info.freezed.dart';

@freezed
abstract class DeviceInfo  with _$DeviceInfo{
  const factory DeviceInfo({
   required final String roomCode,
   required  final String ip,
   required final int tcpPort,
   required  final DateTime lastSeen,
}) = _DeviceInfo;
}
//== END FILE: lib/features/discovery_screen/domain/models/device_info.dart ==//

//== FILE: lib/features/discovery_screen/domain/models/device_info.freezed.dart ==//
// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'device_info.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$DeviceInfo {

 String get roomCode; String get ip; int get tcpPort; DateTime get lastSeen;
/// Create a copy of DeviceInfo
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeviceInfoCopyWith<DeviceInfo> get copyWith => _$DeviceInfoCopyWithImpl<DeviceInfo>(this as DeviceInfo, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeviceInfo&&(identical(other.roomCode, roomCode) || other.roomCode == roomCode)&&(identical(other.ip, ip) || other.ip == ip)&&(identical(other.tcpPort, tcpPort) || other.tcpPort == tcpPort)&&(identical(other.lastSeen, lastSeen) || other.lastSeen == lastSeen));
}


@override
int get hashCode => Object.hash(runtimeType,roomCode,ip,tcpPort,lastSeen);

@override
String toString() {
  return 'DeviceInfo(roomCode: $roomCode, ip: $ip, tcpPort: $tcpPort, lastSeen: $lastSeen)';
}


}

/// @nodoc
abstract mixin class $DeviceInfoCopyWith<$Res>  {
  factory $DeviceInfoCopyWith(DeviceInfo value, $Res Function(DeviceInfo) _then) = _$DeviceInfoCopyWithImpl;
@useResult
$Res call({
 String roomCode, String ip, int tcpPort, DateTime lastSeen
});




}
/// @nodoc
class _$DeviceInfoCopyWithImpl<$Res>
    implements $DeviceInfoCopyWith<$Res> {
  _$DeviceInfoCopyWithImpl(this._self, this._then);

  final DeviceInfo _self;
  final $Res Function(DeviceInfo) _then;

/// Create a copy of DeviceInfo
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? roomCode = null,Object? ip = null,Object? tcpPort = null,Object? lastSeen = null,}) {
  return _then(_self.copyWith(
roomCode: null == roomCode ? _self.roomCode : roomCode // ignore: cast_nullable_to_non_nullable
as String,ip: null == ip ? _self.ip : ip // ignore: cast_nullable_to_non_nullable
as String,tcpPort: null == tcpPort ? _self.tcpPort : tcpPort // ignore: cast_nullable_to_non_nullable
as int,lastSeen: null == lastSeen ? _self.lastSeen : lastSeen // ignore: cast_nullable_to_non_nullable
as DateTime,
  ));
}

}


/// @nodoc


class _DeviceInfo implements DeviceInfo {
  const _DeviceInfo({required this.roomCode, required this.ip, required this.tcpPort, required this.lastSeen});
  

@override final  String roomCode;
@override final  String ip;
@override final  int tcpPort;
@override final  DateTime lastSeen;

/// Create a copy of DeviceInfo
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeviceInfoCopyWith<_DeviceInfo> get copyWith => __$DeviceInfoCopyWithImpl<_DeviceInfo>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeviceInfo&&(identical(other.roomCode, roomCode) || other.roomCode == roomCode)&&(identical(other.ip, ip) || other.ip == ip)&&(identical(other.tcpPort, tcpPort) || other.tcpPort == tcpPort)&&(identical(other.lastSeen, lastSeen) || other.lastSeen == lastSeen));
}


@override
int get hashCode => Object.hash(runtimeType,roomCode,ip,tcpPort,lastSeen);

@override
String toString() {
  return 'DeviceInfo(roomCode: $roomCode, ip: $ip, tcpPort: $tcpPort, lastSeen: $lastSeen)';
}


}

/// @nodoc
abstract mixin class _$DeviceInfoCopyWith<$Res> implements $DeviceInfoCopyWith<$Res> {
  factory _$DeviceInfoCopyWith(_DeviceInfo value, $Res Function(_DeviceInfo) _then) = __$DeviceInfoCopyWithImpl;
@override @useResult
$Res call({
 String roomCode, String ip, int tcpPort, DateTime lastSeen
});




}
/// @nodoc
class __$DeviceInfoCopyWithImpl<$Res>
    implements _$DeviceInfoCopyWith<$Res> {
  __$DeviceInfoCopyWithImpl(this._self, this._then);

  final _DeviceInfo _self;
  final $Res Function(_DeviceInfo) _then;

/// Create a copy of DeviceInfo
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? roomCode = null,Object? ip = null,Object? tcpPort = null,Object? lastSeen = null,}) {
  return _then(_DeviceInfo(
roomCode: null == roomCode ? _self.roomCode : roomCode // ignore: cast_nullable_to_non_nullable
as String,ip: null == ip ? _self.ip : ip // ignore: cast_nullable_to_non_nullable
as String,tcpPort: null == tcpPort ? _self.tcpPort : tcpPort // ignore: cast_nullable_to_non_nullable
as int,lastSeen: null == lastSeen ? _self.lastSeen : lastSeen // ignore: cast_nullable_to_non_nullable
as DateTime,
  ));
}


}

// dart format on

//== END FILE: lib/features/discovery_screen/domain/models/device_info.freezed.dart ==//

//== FILE: lib/features/discovery_screen/presentation/ui/discovery_screen.dart ==//
import 'dart:io';

import 'package:auto_route/auto_route.dart';
import 'package:beam_drop/di/injectable.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:signals_flutter/signals_flutter.dart';
import '../../../../router/app_router.dart';
import '../../../../utils/permissions.dart';
import '../../domain/models/device_info.dart';
import '../controller/connection_controller.dart';
import '../controller/discovery_controller.dart';
@RoutePage()
class DiscoveryScreen extends StatefulWidget{
  @override
  State<DiscoveryScreen> createState() => _DiscoveryScreenState();
}

class _DiscoveryScreenState extends State<DiscoveryScreen> with SignalsMixin {
  final _conn = getIt<ConnectionController>();
  final _disc = getIt<DiscoveryController>();
  final _myRoom = '123456';

  @override
  void initState() {
    super.initState();
    _boot();
  }

  Future<void> _boot() async {

    await requestNecessaryPermissions();
    final port = await _conn.startServer();
    await _disc.start(_myRoom, port);

    _conn.incomingSocket.addListener(() {
      final sock = _conn.incomingSocket.value;
      if (sock != null) context.router.push(TransferRoute(socket: sock, remoteRoomCode: 'Unknown'));
    });
  }

  void _connect(DeviceInfo dev) async {
    final sock = await _conn.connect(dev);
    if (!mounted) return;
    context.router.push(TransferRoute(socket: sock, remoteRoomCode: dev.roomCode));
  }

  @override
  Widget build(BuildContext context) {
    final devices = watchSignal(context, _disc.discovered);

    return Scaffold(
      appBar: AppBar(title: const Text('P2P Discovery')),
      body: ListView.separated(
        itemCount: devices.length,
        separatorBuilder: (_, __) => const Divider(),
        itemBuilder: (_, i) {
          final d = devices[i];
          return ListTile(
            leading: const Icon(Icons.computer),
            title: Text('Room: ${d.roomCode}'),
            subtitle: Text('${d.ip}:${d.tcpPort}'),
            trailing: ElevatedButton(
              onPressed: () => _connect(d),
              child: const Text('Connect'),
            ),
          );
        },
      ),
    );
  }

  @override
  void dispose() {
    _disc.dispose();
    _conn.dispose();
    super.dispose();
  }
}
//== END FILE: lib/features/discovery_screen/presentation/ui/discovery_screen.dart ==//

//== FILE: lib/features/discovery_screen/presentation/controller/discovery_controller.dart ==//
import 'dart:io';

import 'package:flutter/cupertino.dart';
import 'package:injectable/injectable.dart';

import '../../application/discovery_service.dart';
import '../../application/tcp_client.dart';
import '../../application/tcp_server.dart';
import 'package:signals_flutter/signals_flutter.dart';

import '../../domain/models/device_info.dart';
@LazySingleton()
class DiscoveryController {


  final DiscoveryService _svc = DiscoveryService.instance;

  // signal<List<DeviceInfo>>
  final discovered = signal(<DeviceInfo>[]);

  Future<void> start(String roomCode, int tcpPort) async {
    await _svc.start(roomCode, tcpPort);
    _svc.devicesStream.listen((list) => discovered.value = List.unmodifiable(list));
  }

  void dispose() {
    _svc.stop();
    discovered.dispose();
  }
}
//== END FILE: lib/features/discovery_screen/presentation/controller/discovery_controller.dart ==//

//== FILE: lib/features/discovery_screen/presentation/controller/connection_controller.dart ==//
import 'dart:io';

import 'package:injectable/injectable.dart';
import 'package:signals_flutter/signals_core.dart';

import '../../application/tcp_client.dart';
import '../../application/tcp_server.dart';
import '../../domain/models/device_info.dart';
@LazySingleton()
class ConnectionController {

  ConnectionController({required this.client,required this.server});

  final TcpServer server;
  final TcpClient client;

  /// Сокет входящего коннекта (когда кто‑то подключился к нам)
  final incomingSocket = signal<Socket?>(null);

  Future<int> startServer({int preferredPort = 8080}) async {
    final port = await server.start(preferredPort: preferredPort);
    server.clientStream.listen((sock) => incomingSocket.value = sock);
    return port;
  }

  Future<Socket> connect(DeviceInfo target) async {
    return client.connect(target.ip, target.tcpPort);
  }

  void dispose() {
    server.stop();
    incomingSocket.dispose();
  }
}
//== END FILE: lib/features/discovery_screen/presentation/controller/connection_controller.dart ==//

//== FILE: lib/utils/permissions.dart ==//
import 'dart:io';

import 'package:permission_handler/permission_handler.dart';

Future<void> requestNecessaryPermissions() async {
 if(Platform.isAndroid){
   await [
     Permission.storage,
     Permission.nearbyWifiDevices, // Android 13+
   ].request();
 }
}
//== END FILE: lib/utils/permissions.dart ==//

//== FILE: lib/main.dart ==//
import 'package:beam_drop/di/injectable.dart';
import 'package:beam_drop/router/app_router.dart';
import 'package:flutter/material.dart';


void main() {
  configureDependencies();
  runApp(MyApp());
}

class MyApp extends StatelessWidget {

  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerConfig: getIt<AppRouter>().config(),
    );
  }
}

//== END FILE: lib/main.dart ==//

//== FILE: lib/router/app_router.gr.dart ==//
// dart format width=80
// GENERATED CODE - DO NOT MODIFY BY HAND

// **************************************************************************
// AutoRouterGenerator
// **************************************************************************

// ignore_for_file: type=lint
// coverage:ignore-file

part of 'app_router.dart';

/// generated route for
/// [DiscoveryScreen]
class DiscoveryRoute extends PageRouteInfo<void> {
  const DiscoveryRoute({List<PageRouteInfo>? children})
    : super(DiscoveryRoute.name, initialChildren: children);

  static const String name = 'DiscoveryRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return DiscoveryScreen();
    },
  );
}

/// generated route for
/// [TransferScreen]
class TransferRoute extends PageRouteInfo<TransferRouteArgs> {
  TransferRoute({
    Key? key,
    required Socket socket,
    required String remoteRoomCode,
    List<PageRouteInfo>? children,
  }) : super(
         TransferRoute.name,
         args: TransferRouteArgs(
           key: key,
           socket: socket,
           remoteRoomCode: remoteRoomCode,
         ),
         initialChildren: children,
       );

  static const String name = 'TransferRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      final args = data.argsAs<TransferRouteArgs>();
      return TransferScreen(
        key: args.key,
        socket: args.socket,
        remoteRoomCode: args.remoteRoomCode,
      );
    },
  );
}

class TransferRouteArgs {
  const TransferRouteArgs({
    this.key,
    required this.socket,
    required this.remoteRoomCode,
  });

  final Key? key;

  final Socket socket;

  final String remoteRoomCode;

  @override
  String toString() {
    return 'TransferRouteArgs{key: $key, socket: $socket, remoteRoomCode: $remoteRoomCode}';
  }
}

//== END FILE: lib/router/app_router.gr.dart ==//

//== FILE: lib/router/app_router.dart ==//
import 'dart:io';

import 'package:auto_route/auto_route.dart';
import 'package:flutter/material.dart';

import '../features/discovery_screen/presentation/ui/discovery_screen.dart';
import '../features/transfer_screen/presentation/ui/transfer_sceren.dart';




part 'app_router.gr.dart';

@AutoRouterConfig(replaceInRouteName: 'Screen|Page,Route')
class AppRouter extends RootStackRouter {
  @override
  List<AutoRoute> get routes => [
    // AutoRoute(page: LoginRoute.page, initial: true),
    // AutoRoute(page: HomeRoute.page),
    // AutoRoute(page: ProfileRoute.page),
    AutoRoute(page: DiscoveryRoute.page,initial: true),
    AutoRoute(page: TransferRoute.page),
  ];
}

//== END FILE: lib/router/app_router.dart ==//

